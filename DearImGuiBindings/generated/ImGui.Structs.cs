// <auto-generated/>
namespace ImGuiNative;
using static ImGuiConsts;

/// <summary>
/// Data shared among multiple draw lists (typically owned by parent ImGui context, but you may create one yourself)
/// </summary>
public struct ImDrawListSharedData
{
}
/// <summary>
/// Opaque interface to a font builder (stb_truetype or FreeType).
/// </summary>
public struct ImFontBuilderIO
{
}
/// <summary>
/// Dear ImGui context (opaque structure, unless including imgui_internal.h)
/// </summary>
public struct ImGuiContext
{
}
public struct ImVec2
{
	public float x;

	public float y;

}
/// <summary>
/// <para>ImVec4: 4D vector used to store clipping rectangles, colors etc. [Compile-time configurable type]</para>
/// </summary>
public struct ImVec4
{
	public float x;

	public float y;

	public float z;

	public float w;

}
/// <summary>
/// <para>Sorting specifications for a table (often handling sort specs for a single column, occasionally more)</para>
/// <para>Obtained by calling TableGetSortSpecs().</para>
/// <para>When 'SpecsDirty == true' you can sort your data. It will be true with sorting specs have changed since last call, or the first time.</para>
/// <para>Make sure to set 'SpecsDirty = false' after sorting, else you may wastefully sort your data every frame!</para>
/// </summary>
public struct ImGuiTableSortSpecs
{
	/// <summary>
	/// Pointer to sort spec array.
	/// </summary>
	public unsafe ImGuiTableColumnSortSpecs* Specs;

	/// <summary>
	/// Sort spec count. Most often 1. May be &gt; 1 when ImGuiTableFlags_SortMulti is enabled. May be == 0 when ImGuiTableFlags_SortTristate is enabled.
	/// </summary>
	public int SpecsCount;

	/// <summary>
	/// Set to true when specs have changed since last time! Use this to sort again, then clear the flag.
	/// </summary>
	public bool SpecsDirty;

}
/// <summary>
/// <para>Sorting specification for one column of a table (sizeof == 12 bytes)</para>
/// </summary>
public struct ImGuiTableColumnSortSpecs
{
	/// <summary>
	/// User id of the column (if specified by a TableSetupColumn() call)
	/// </summary>
	/// <returns>Original type: ImGuiID</returns>
	public uint ColumnUserID;

	/// <summary>
	/// Index of the column
	/// </summary>
	/// <returns>Original type: ImS16</returns>
	public short ColumnIndex;

	/// <summary>
	/// Index within parent ImGuiTableSortSpecs (always stored in order starting from 0, tables sorted on a single criteria will always have a 0 here)
	/// </summary>
	/// <returns>Original type: ImS16</returns>
	public short SortOrder;

	/// <summary>
	/// ImGuiSortDirection_Ascending or ImGuiSortDirection_Descending
	/// </summary>
	public ImGuiSortDirection SortDirection;

}
public struct ImVector_ImWchar
{
	public int Size;

	public int Capacity;

	/// <returns>Original type: ImWchar*</returns>
	public unsafe ushort* Data;

}
public struct ImVector_ImGuiTextFilter_ImGuiTextRange
{
	public int Size;

	public int Capacity;

	public unsafe ImGuiTextFilter_ImGuiTextRange* Data;

}
public struct ImVector_char
{
	public int Size;

	public int Capacity;

	public unsafe byte* Data;

}
public struct ImVector_ImGuiStorage_ImGuiStoragePair
{
	public int Size;

	public int Capacity;

	public unsafe ImGuiStorage_ImGuiStoragePair* Data;

}
public struct ImVector_ImDrawCmd
{
	public int Size;

	public int Capacity;

	public unsafe ImDrawCmd* Data;

}
public struct ImVector_ImDrawIdx
{
	public int Size;

	public int Capacity;

	/// <returns>Original type: ImDrawIdx*</returns>
	public unsafe ushort* Data;

}
public struct ImVector_ImDrawChannel
{
	public int Size;

	public int Capacity;

	public unsafe ImDrawChannel* Data;

}
public struct ImVector_ImDrawVert
{
	public int Size;

	public int Capacity;

	public unsafe ImDrawVert* Data;

}
public struct ImVector_ImVec4
{
	public int Size;

	public int Capacity;

	public unsafe ImVec4* Data;

}
public struct ImVector_ImTextureID
{
	public int Size;

	public int Capacity;

	/// <returns>Original type: ImTextureID*</returns>
	public unsafe void** Data;

}
public struct ImVector_ImVec2
{
	public int Size;

	public int Capacity;

	public unsafe ImVec2* Data;

}
public struct ImVector_ImDrawListPtr
{
	public int Size;

	public int Capacity;

	public unsafe ImDrawList** Data;

}
public struct ImVector_ImU32
{
	public int Size;

	public int Capacity;

	/// <returns>Original type: ImU32*</returns>
	public unsafe uint* Data;

}
public struct ImVector_ImFontPtr
{
	public int Size;

	public int Capacity;

	public unsafe ImFont** Data;

}
public struct ImVector_ImFontAtlasCustomRect
{
	public int Size;

	public int Capacity;

	public unsafe ImFontAtlasCustomRect* Data;

}
public struct ImVector_ImFontConfig
{
	public int Size;

	public int Capacity;

	public unsafe ImFontConfig* Data;

}
public struct ImVector_float
{
	public int Size;

	public int Capacity;

	public unsafe float* Data;

}
public struct ImVector_ImFontGlyph
{
	public int Size;

	public int Capacity;

	public unsafe ImFontGlyph* Data;

}
public struct ImGuiStyle
{
	/// <summary>
	/// Global alpha applies to everything in Dear ImGui.
	/// </summary>
	public float Alpha;

	/// <summary>
	/// Additional alpha multiplier applied by BeginDisabled(). Multiply over current value of Alpha.
	/// </summary>
	public float DisabledAlpha;

	/// <summary>
	/// Padding within a window.
	/// </summary>
	public ImVec2 WindowPadding;

	/// <summary>
	/// Radius of window corners rounding. Set to 0.0f to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.
	/// </summary>
	public float WindowRounding;

	/// <summary>
	/// Thickness of border around windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
	/// </summary>
	public float WindowBorderSize;

	/// <summary>
	/// Minimum window size. This is a global setting. If you want to constrain individual windows, use SetNextWindowSizeConstraints().
	/// </summary>
	public ImVec2 WindowMinSize;

	/// <summary>
	/// Alignment for title bar text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.
	/// </summary>
	public ImVec2 WindowTitleAlign;

	/// <summary>
	/// Side of the collapsing/docking button in the title bar (None/Left/Right). Defaults to ImGuiDir_Left.
	/// </summary>
	public ImGuiDir WindowMenuButtonPosition;

	/// <summary>
	/// Radius of child window corners rounding. Set to 0.0f to have rectangular windows.
	/// </summary>
	public float ChildRounding;

	/// <summary>
	/// Thickness of border around child windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
	/// </summary>
	public float ChildBorderSize;

	/// <summary>
	/// Radius of popup window corners rounding. (Note that tooltip windows use WindowRounding)
	/// </summary>
	public float PopupRounding;

	/// <summary>
	/// Thickness of border around popup/tooltip windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
	/// </summary>
	public float PopupBorderSize;

	/// <summary>
	/// Padding within a framed rectangle (used by most widgets).
	/// </summary>
	public ImVec2 FramePadding;

	/// <summary>
	/// Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).
	/// </summary>
	public float FrameRounding;

	/// <summary>
	/// Thickness of border around frames. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
	/// </summary>
	public float FrameBorderSize;

	/// <summary>
	/// Horizontal and vertical spacing between widgets/lines.
	/// </summary>
	public ImVec2 ItemSpacing;

	/// <summary>
	/// Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label).
	/// </summary>
	public ImVec2 ItemInnerSpacing;

	/// <summary>
	/// Padding within a table cell. CellPadding.y may be altered between different rows.
	/// </summary>
	public ImVec2 CellPadding;

	/// <summary>
	/// Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
	/// </summary>
	public ImVec2 TouchExtraPadding;

	/// <summary>
	/// Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
	/// </summary>
	public float IndentSpacing;

	/// <summary>
	/// Minimum horizontal spacing between two columns. Preferably &gt; (FramePadding.x + 1).
	/// </summary>
	public float ColumnsMinSpacing;

	/// <summary>
	/// Width of the vertical scrollbar, Height of the horizontal scrollbar.
	/// </summary>
	public float ScrollbarSize;

	/// <summary>
	/// Radius of grab corners for scrollbar.
	/// </summary>
	public float ScrollbarRounding;

	/// <summary>
	/// Minimum width/height of a grab box for slider/scrollbar.
	/// </summary>
	public float GrabMinSize;

	/// <summary>
	/// Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
	/// </summary>
	public float GrabRounding;

	/// <summary>
	/// The size in pixels of the dead-zone around zero on logarithmic sliders that cross zero.
	/// </summary>
	public float LogSliderDeadzone;

	/// <summary>
	/// Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
	/// </summary>
	public float TabRounding;

	/// <summary>
	/// Thickness of border around tabs.
	/// </summary>
	public float TabBorderSize;

	/// <summary>
	/// Minimum width for close button to appear on an unselected tab when hovered. Set to 0.0f to always show when hovering, set to FLT_MAX to never show close button unless selected.
	/// </summary>
	public float TabMinWidthForCloseButton;

	/// <summary>
	/// Thickness of tab-bar separator, which takes on the tab active color to denote focus.
	/// </summary>
	public float TabBarBorderSize;

	/// <summary>
	/// Angle of angled headers (supported values range from -50.0f degrees to +50.0f degrees).
	/// </summary>
	public float TableAngledHeadersAngle;

	/// <summary>
	/// Side of the color button in the ColorEdit4 widget (left/right). Defaults to ImGuiDir_Right.
	/// </summary>
	public ImGuiDir ColorButtonPosition;

	/// <summary>
	/// Alignment of button text when button is larger than text. Defaults to (0.5f, 0.5f) (centered).
	/// </summary>
	public ImVec2 ButtonTextAlign;

	/// <summary>
	/// Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.
	/// </summary>
	public ImVec2 SelectableTextAlign;

	/// <summary>
	/// Thickkness of border in SeparatorText()
	/// </summary>
	public float SeparatorTextBorderSize;

	/// <summary>
	/// Alignment of text within the separator. Defaults to (0.0f, 0.5f) (left aligned, center).
	/// </summary>
	public ImVec2 SeparatorTextAlign;

	/// <summary>
	/// Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.
	/// </summary>
	public ImVec2 SeparatorTextPadding;

	/// <summary>
	/// Window position are clamped to be visible within the display area or monitors by at least this amount. Only applies to regular windows.
	/// </summary>
	public ImVec2 DisplayWindowPadding;

	/// <summary>
	/// If you cannot see the edges of your screen (e.g. on a TV) increase the safe area padding. Apply to popups/tooltips as well regular windows. NB: Prefer configuring your TV sets correctly!
	/// </summary>
	public ImVec2 DisplaySafeAreaPadding;

	/// <summary>
	/// Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
	/// </summary>
	public float MouseCursorScale;

	/// <summary>
	/// Enable anti-aliased lines/borders. Disable if you are really tight on CPU/GPU. Latched at the beginning of the frame (copied to ImDrawList).
	/// </summary>
	public bool AntiAliasedLines;

	/// <summary>
	/// Enable anti-aliased lines/borders using textures where possible. Require backend to render with bilinear filtering (NOT point/nearest filtering). Latched at the beginning of the frame (copied to ImDrawList).
	/// </summary>
	public bool AntiAliasedLinesUseTex;

	/// <summary>
	/// Enable anti-aliased edges around filled shapes (rounded rectangles, circles, etc.). Disable if you are really tight on CPU/GPU. Latched at the beginning of the frame (copied to ImDrawList).
	/// </summary>
	public bool AntiAliasedFill;

	/// <summary>
	/// Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
	/// </summary>
	public float CurveTessellationTol;

	/// <summary>
	/// Maximum error (in pixels) allowed when using AddCircle()/AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.
	/// </summary>
	public float CircleTessellationMaxError;

	public ImGuiStyle_ColorsInlineArray Colors;

	/// <summary>
	/// <para>Behaviors</para>
	/// <para>(It is possible to modify those fields mid-frame if specific behavior need it, unlike e.g. configuration fields in ImGuiIO)</para>
	/// </summary>
	/// <para/><summary>
	/// Delay for IsItemHovered(ImGuiHoveredFlags_Stationary). Time required to consider mouse stationary.
	/// </summary>
	public float HoverStationaryDelay;

	/// <summary>
	/// Delay for IsItemHovered(ImGuiHoveredFlags_DelayShort). Usually used along with HoverStationaryDelay.
	/// </summary>
	public float HoverDelayShort;

	/// <summary>
	/// Delay for IsItemHovered(ImGuiHoveredFlags_DelayNormal). "
	/// </summary>
	public float HoverDelayNormal;

	/// <summary>
	/// Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using mouse.
	/// </summary>
	public ImGuiHoveredFlags HoverFlagsForTooltipMouse;

	/// <summary>
	/// Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using keyboard/gamepad.
	/// </summary>
	public ImGuiHoveredFlags HoverFlagsForTooltipNav;

}
/// <summary>
/// <para>[Internal] Storage used by IsKeyDown(), IsKeyPressed() etc functions.</para>
/// <para>If prior to 1.87 you used io.KeysDownDuration[] (which was marked as internal), you should use GetKeyData(key)-&gt;DownDuration and *NOT* io.KeysData[key]-&gt;DownDuration.</para>
/// </summary>
public struct ImGuiKeyData
{
	/// <summary>
	/// True for if key is down
	/// </summary>
	public bool Down;

	/// <summary>
	/// Duration the key has been down (&lt;0.0f: not pressed, 0.0f: just pressed, &gt;0.0f: time held)
	/// </summary>
	public float DownDuration;

	/// <summary>
	/// Last frame duration the key has been down
	/// </summary>
	public float DownDurationPrev;

	/// <summary>
	/// 0.0f..1.0f for gamepad values
	/// </summary>
	public float AnalogValue;

}
public struct ImGuiIO
{
	/// <summary>
	/// = 0              // See ImGuiConfigFlags_ enum. Set by user/application. Gamepad/keyboard navigation options, etc.
	/// </summary>
	public ImGuiConfigFlags ConfigFlags;

	/// <summary>
	/// = 0              // See ImGuiBackendFlags_ enum. Set by backend (imgui_impl_xxx files or custom backend) to communicate features supported by the backend.
	/// </summary>
	public ImGuiBackendFlags BackendFlags;

	/// <summary>
	/// &lt;unset&gt;          // Main display size, in pixels (generally == GetMainViewport()-&gt;Size). May change every frame.
	/// </summary>
	public ImVec2 DisplaySize;

	/// <summary>
	/// = 1.0f/60.0f     // Time elapsed since last frame, in seconds. May change every frame.
	/// </summary>
	public float DeltaTime;

	/// <summary>
	/// = 5.0f           // Minimum time between saving positions/sizes to .ini file, in seconds.
	/// </summary>
	public float IniSavingRate;

	/// <summary>
	/// = "imgui.ini"    // Path to .ini file (important: default "imgui.ini" is relative to current working dir!). Set NULL to disable automatic .ini loading/saving or if you want to manually call LoadIniSettingsXXX() / SaveIniSettingsXXX() functions.
	/// </summary>
	public unsafe byte* IniFilename;

	/// <summary>
	/// = "imgui_log.txt"// Path to .log file (default parameter to ImGui::LogToFile when no file is specified).
	/// </summary>
	public unsafe byte* LogFilename;

	/// <summary>
	/// = NULL           // Store your own data.
	/// </summary>
	public unsafe void* UserData;

	/// <summary>
	/// &lt;auto&gt;           // Font atlas: load, rasterize and pack one or more fonts into a single texture.
	/// </summary>
	public unsafe ImFontAtlas* Fonts;

	/// <summary>
	/// = 1.0f           // Global scale all fonts
	/// </summary>
	public float FontGlobalScale;

	/// <summary>
	/// = false          // Allow user scaling text of individual window with CTRL+Wheel.
	/// </summary>
	public bool FontAllowUserScaling;

	/// <summary>
	/// = NULL           // Font to use on NewFrame(). Use NULL to uses Fonts-&gt;Fonts[0].
	/// </summary>
	public unsafe ImFont* FontDefault;

	/// <summary>
	/// = (1, 1)         // For retina display or other situations where window coordinates are different from framebuffer coordinates. This generally ends up in ImDrawData::FramebufferScale.
	/// </summary>
	public ImVec2 DisplayFramebufferScale;

	/// <summary>
	/// <para>Miscellaneous options</para>
	/// </summary>
	/// <para/><summary>
	/// = false          // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor). Cannot be easily renamed to 'io.ConfigXXX' because this is frequently used by backend implementations.
	/// </summary>
	public bool MouseDrawCursor;

	/// <summary>
	/// = defined(__APPLE__) // OS X style: Text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl.
	/// </summary>
	public bool ConfigMacOSXBehaviors;

	/// <summary>
	/// = true           // Enable input queue trickling: some types of events submitted during the same frame (e.g. button down + up) will be spread over multiple frames, improving interactions with low framerates.
	/// </summary>
	public bool ConfigInputTrickleEventQueue;

	/// <summary>
	/// = true           // Enable blinking cursor (optional as some users consider it to be distracting).
	/// </summary>
	public bool ConfigInputTextCursorBlink;

	/// <summary>
	/// = false          // [BETA] Pressing Enter will keep item active and select contents (single-line only).
	/// </summary>
	public bool ConfigInputTextEnterKeepActive;

	/// <summary>
	/// = false          // [BETA] Enable turning DragXXX widgets into text input with a simple mouse click-release (without moving). Not desirable on devices without a keyboard.
	/// </summary>
	public bool ConfigDragClickToInputText;

	/// <summary>
	/// = true           // Enable resizing of windows from their edges and from the lower-left corner. This requires (io.BackendFlags &amp; ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback. (This used to be a per-window ImGuiWindowFlags_ResizeFromAnySide flag)
	/// </summary>
	public bool ConfigWindowsResizeFromEdges;

	/// <summary>
	/// = false       // Enable allowing to move windows only when clicking on their title bar. Does not apply to windows without a title bar.
	/// </summary>
	public bool ConfigWindowsMoveFromTitleBarOnly;

	/// <summary>
	/// = 60.0f          // Timer (in seconds) to free transient windows/tables memory buffers when unused. Set to -1.0f to disable.
	/// </summary>
	public float ConfigMemoryCompactTimer;

	/// <summary>
	/// <para>Inputs Behaviors</para>
	/// <para>(other variables, ones which are expected to be tweaked within UI code, are exposed in ImGuiStyle)</para>
	/// </summary>
	/// <para/><summary>
	/// = 0.30f          // Time for a double-click, in seconds.
	/// </summary>
	public float MouseDoubleClickTime;

	/// <summary>
	/// = 6.0f           // Distance threshold to stay in to validate a double-click, in pixels.
	/// </summary>
	public float MouseDoubleClickMaxDist;

	/// <summary>
	/// = 6.0f           // Distance threshold before considering we are dragging.
	/// </summary>
	public float MouseDragThreshold;

	/// <summary>
	/// = 0.275f         // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).
	/// </summary>
	public float KeyRepeatDelay;

	/// <summary>
	/// = 0.050f         // When holding a key/button, rate at which it repeats, in seconds.
	/// </summary>
	public float KeyRepeatRate;

	/// <summary>
	/// <para>Option to enable various debug tools showing buttons that will call the IM_DEBUG_BREAK() macro.</para>
	/// <para>- The Item Picker tool will be available regardless of this being enabled, in order to maximize its discoverability.</para>
	/// <para>- Requires a debugger being attached, otherwise IM_DEBUG_BREAK() options will appear to crash your application.</para>
	/// <para>  e.g. io.ConfigDebugIsDebuggerPresent = ::IsDebuggerPresent() on Win32, or refer to ImOsIsDebuggerPresent() imgui_test_engine/imgui_te_utils.cpp for a Unix compatible version).</para>
	/// </summary>
	/// <para/><summary>
	/// = false          // Enable various tools calling IM_DEBUG_BREAK().
	/// </summary>
	public bool ConfigDebugIsDebuggerPresent;

	/// <summary>
	/// <para>Tools to test correct Begin/End and BeginChild/EndChild behaviors.</para>
	/// <para>- Presently Begin()/End() and BeginChild()/EndChild() needs to ALWAYS be called in tandem, regardless of return value of BeginXXX()</para>
	/// <para>- This is inconsistent with other BeginXXX functions and create confusion for many users.</para>
	/// <para>- We expect to update the API eventually. In the meanwhile we provide tools to facilitate checking user-code behavior.</para>
	/// </summary>
	/// <para/><summary>
	/// = false          // First-time calls to Begin()/BeginChild() will return false. NEEDS TO BE SET AT APPLICATION BOOT TIME if you don't want to miss windows.
	/// </summary>
	public bool ConfigDebugBeginReturnValueOnce;

	/// <summary>
	/// = false          // Some calls to Begin()/BeginChild() will return false. Will cycle through window depths then repeat. Suggested use: add "io.ConfigDebugBeginReturnValue = io.KeyShift" in your main loop then occasionally press SHIFT. Windows should be flickering while running.
	/// </summary>
	public bool ConfigDebugBeginReturnValueLoop;

	/// <summary>
	/// <para>Option to deactivate io.AddFocusEvent(false) handling.</para>
	/// <para>- May facilitate interactions with a debugger when focus loss leads to clearing inputs data.</para>
	/// <para>- Backends may have other side-effects on focus loss, so this will reduce side-effects but not necessary remove all of them.</para>
	/// </summary>
	/// <para/><summary>
	/// = false          // Ignore io.AddFocusEvent(false), consequently not calling io.ClearInputKeys() in input processing.
	/// </summary>
	public bool ConfigDebugIgnoreFocusLoss;

	/// <summary>
	/// <para>Options to audit .ini data</para>
	/// </summary>
	/// <para/><summary>
	/// = false          // Save .ini data with extra comments (particularly helpful for Docking, but makes saving slower)
	/// </summary>
	public bool ConfigDebugIniSettings;

	/// <summary>
	/// <para>Optional: Platform/Renderer backend name (informational only! will be displayed in About Window) + User data for backend/wrappers to store their own stuff.</para>
	/// </summary>
	/// <para/><summary>
	/// = NULL
	/// </summary>
	public unsafe byte* BackendPlatformName;

	/// <summary>
	/// = NULL
	/// </summary>
	public unsafe byte* BackendRendererName;

	/// <summary>
	/// = NULL           // User data for platform backend
	/// </summary>
	public unsafe void* BackendPlatformUserData;

	/// <summary>
	/// = NULL           // User data for renderer backend
	/// </summary>
	public unsafe void* BackendRendererUserData;

	/// <summary>
	/// = NULL           // User data for non C++ programming language backend
	/// </summary>
	public unsafe void* BackendLanguageUserData;

	/// <summary>
	/// <para>Optional: Access OS clipboard</para>
	/// <para>(default to use native Win32 clipboard on Windows, otherwise uses a private clipboard. Override to access OS clipboard on other architectures)</para>
	/// </summary>
	public unsafe GetClipboardTextFnDelegate* GetClipboardTextFn;

	public unsafe SetClipboardTextFnDelegate* SetClipboardTextFn;

	public unsafe void* ClipboardUserData;

	/// <summary>
	/// <para>Optional: Notify OS Input Method Editor of the screen position of your cursor for text input position (e.g. when using Japanese/Chinese IME on Windows)</para>
	/// <para>(default to use native imm32 api on Windows)</para>
	/// </summary>
	public unsafe SetPlatformImeDataFnDelegate* SetPlatformImeDataFn;

	/// <summary>
	/// <para>Optional: Platform locale</para>
	/// </summary>
	/// <para/><summary>
	/// '.'              // [Experimental] Configure decimal point e.g. '.' or ',' useful for some languages (e.g. German), generally pulled from *localeconv()-&gt;decimal_point
	/// </summary>
	/// <returns>Original type: ImWchar</returns>
	public ushort PlatformLocaleDecimalPoint;

	/// <summary>
	/// Set when Dear ImGui will use mouse inputs, in this case do not dispatch them to your main game/application (either way, always pass on mouse inputs to imgui). (e.g. unclicked mouse is hovering over an imgui window, widget is active, mouse was clicked over an imgui window, etc.).
	/// </summary>
	public bool WantCaptureMouse;

	/// <summary>
	/// Set when Dear ImGui will use keyboard inputs, in this case do not dispatch them to your main game/application (either way, always pass keyboard inputs to imgui). (e.g. InputText active, or an imgui window is focused and navigation is enabled, etc.).
	/// </summary>
	public bool WantCaptureKeyboard;

	/// <summary>
	/// Mobile/console: when set, you may display an on-screen keyboard. This is set by Dear ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).
	/// </summary>
	public bool WantTextInput;

	/// <summary>
	/// MousePos has been altered, backend should reposition mouse on next frame. Rarely used! Set only when ImGuiConfigFlags_NavEnableSetMousePos flag is enabled.
	/// </summary>
	public bool WantSetMousePos;

	/// <summary>
	/// When manual .ini load/save is active (io.IniFilename == NULL), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. Important: clear io.WantSaveIniSettings yourself after saving!
	/// </summary>
	public bool WantSaveIniSettings;

	/// <summary>
	/// Keyboard/Gamepad navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.
	/// </summary>
	public bool NavActive;

	/// <summary>
	/// Keyboard/Gamepad navigation is visible and allowed (will handle ImGuiKey_NavXXX events).
	/// </summary>
	public bool NavVisible;

	/// <summary>
	/// Estimate of application framerate (rolling average over 60 frames, based on io.DeltaTime), in frame per second. Solely for convenience. Slow applications may not want to use a moving average or may want to reset underlying buffers occasionally.
	/// </summary>
	public float Framerate;

	/// <summary>
	/// Vertices output during last call to Render()
	/// </summary>
	public int MetricsRenderVertices;

	/// <summary>
	/// Indices output during last call to Render() = number of triangles * 3
	/// </summary>
	public int MetricsRenderIndices;

	/// <summary>
	/// Number of visible windows
	/// </summary>
	public int MetricsRenderWindows;

	/// <summary>
	/// Number of active windows
	/// </summary>
	public int MetricsActiveWindows;

	/// <summary>
	/// Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.
	/// </summary>
	public ImVec2 MouseDelta;

	/// <summary>
	/// Parent UI context (needs to be set explicitly by parent).
	/// </summary>
	public unsafe ImGuiContext* Ctx;

	/// <summary>
	/// <para>Main Input State</para>
	/// <para>(this block used to be written by backend, since 1.87 it is best to NOT write to those directly, call the AddXXX functions above instead)</para>
	/// <para>(reading from those variables is fair game, as they are extremely unlikely to be moving anywhere)</para>
	/// </summary>
	/// <para/><summary>
	/// Mouse position, in pixels. Set to ImVec2(-FLT_MAX, -FLT_MAX) if mouse is unavailable (on another screen, etc.)
	/// </summary>
	public ImVec2 MousePos;

	/// <summary>
	/// Mouse buttons: 0=left, 1=right, 2=middle + extras (ImGuiMouseButton_COUNT == 5). Dear ImGui mostly uses left and right buttons. Other buttons allow us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.
	/// </summary>
	public unsafe fixed bool MouseDown[5];

	/// <summary>
	/// Mouse wheel Vertical: 1 unit scrolls about 5 lines text. &gt;0 scrolls Up, &lt;0 scrolls Down. Hold SHIFT to turn vertical scroll into horizontal scroll.
	/// </summary>
	public float MouseWheel;

	/// <summary>
	/// Mouse wheel Horizontal. &gt;0 scrolls Left, &lt;0 scrolls Right. Most users don't have a mouse with a horizontal wheel, may not be filled by all backends.
	/// </summary>
	public float MouseWheelH;

	/// <summary>
	/// Mouse actual input peripheral (Mouse/TouchScreen/Pen).
	/// </summary>
	public ImGuiMouseSource MouseSource;

	/// <summary>
	/// Keyboard modifier down: Control
	/// </summary>
	public bool KeyCtrl;

	/// <summary>
	/// Keyboard modifier down: Shift
	/// </summary>
	public bool KeyShift;

	/// <summary>
	/// Keyboard modifier down: Alt
	/// </summary>
	public bool KeyAlt;

	/// <summary>
	/// Keyboard modifier down: Cmd/Super/Windows
	/// </summary>
	public bool KeySuper;

	/// <summary>
	/// <para>Other state maintained from data above + IO function calls</para>
	/// </summary>
	/// <para/><summary>
	/// Key mods flags (any of ImGuiMod_Ctrl/ImGuiMod_Shift/ImGuiMod_Alt/ImGuiMod_Super flags, same as io.KeyCtrl/KeyShift/KeyAlt/KeySuper but merged into flags. DOES NOT CONTAINS ImGuiMod_Shortcut which is pretranslated). Read-only, updated by NewFrame()
	/// </summary>
	/// <returns>Original type: ImGuiKeyChord</returns>
	public int KeyMods;

	/// <summary>
	/// Key state for all known keys. Use IsKeyXXX() functions to access this.
	/// </summary>
	public ImGuiIO_KeysDataInlineArray KeysData;

	/// <summary>
	/// Alternative to WantCaptureMouse: (WantCaptureMouse == true &amp;&amp; WantCaptureMouseUnlessPopupClose == false) when a click over void is expected to close a popup.
	/// </summary>
	public bool WantCaptureMouseUnlessPopupClose;

	/// <summary>
	/// Previous mouse position (note that MouseDelta is not necessary == MousePos-MousePosPrev, in case either position is invalid)
	/// </summary>
	public ImVec2 MousePosPrev;

	/// <summary>
	/// Position at time of clicking
	/// </summary>
	public ImGuiIO_MouseClickedPosInlineArray MouseClickedPos;

	/// <summary>
	/// Time of last click (used to figure out double-click)
	/// </summary>
	public unsafe fixed double MouseClickedTime[5];

	/// <summary>
	/// Mouse button went from !Down to Down (same as MouseClickedCount[x] != 0)
	/// </summary>
	public unsafe fixed bool MouseClicked[5];

	/// <summary>
	/// Has mouse button been double-clicked? (same as MouseClickedCount[x] == 2)
	/// </summary>
	public unsafe fixed bool MouseDoubleClicked[5];

	/// <summary>
	/// == 0 (not clicked), == 1 (same as MouseClicked[]), == 2 (double-clicked), == 3 (triple-clicked) etc. when going from !Down to Down
	/// </summary>
	/// <returns>Original type: ImU16</returns>
	public unsafe fixed ushort MouseClickedCount[5];

	/// <summary>
	/// Count successive number of clicks. Stays valid after mouse release. Reset after another click is done.
	/// </summary>
	/// <returns>Original type: ImU16</returns>
	public unsafe fixed ushort MouseClickedLastCount[5];

	/// <summary>
	/// Mouse button went from Down to !Down
	/// </summary>
	public unsafe fixed bool MouseReleased[5];

	/// <summary>
	/// Track if button was clicked inside a dear imgui window or over void blocked by a popup. We don't request mouse capture from the application if click started outside ImGui bounds.
	/// </summary>
	public unsafe fixed bool MouseDownOwned[5];

	/// <summary>
	/// Track if button was clicked inside a dear imgui window.
	/// </summary>
	public unsafe fixed bool MouseDownOwnedUnlessPopupClose[5];

	/// <summary>
	/// On a non-Mac system, holding SHIFT requests WheelY to perform the equivalent of a WheelX event. On a Mac system this is already enforced by the system.
	/// </summary>
	public bool MouseWheelRequestAxisSwap;

	/// <summary>
	/// Duration the mouse button has been down (0.0f == just clicked)
	/// </summary>
	public unsafe fixed float MouseDownDuration[5];

	/// <summary>
	/// Previous time the mouse button has been down
	/// </summary>
	public unsafe fixed float MouseDownDurationPrev[5];

	/// <summary>
	/// Squared maximum distance of how much mouse has traveled from the clicking point (used for moving thresholds)
	/// </summary>
	public unsafe fixed float MouseDragMaxDistanceSqr[5];

	/// <summary>
	/// Touch/Pen pressure (0.0f to 1.0f, should be &gt;0.0f only when MouseDown[0] == true). Helper storage currently unused by Dear ImGui.
	/// </summary>
	public float PenPressure;

	/// <summary>
	/// Only modify via AddFocusEvent()
	/// </summary>
	public bool AppFocusLost;

	/// <summary>
	/// Only modify via SetAppAcceptingEvents()
	/// </summary>
	public bool AppAcceptingEvents;

	/// <summary>
	/// -1: unknown, 0: using AddKeyEvent(), 1: using legacy io.KeysDown[]
	/// </summary>
	/// <returns>Original type: ImS8</returns>
	public byte BackendUsingLegacyKeyArrays;

	/// <summary>
	/// 0: using AddKeyAnalogEvent(), 1: writing to legacy io.NavInputs[] directly
	/// </summary>
	public bool BackendUsingLegacyNavInputArray;

	/// <summary>
	/// For AddInputCharacterUTF16()
	/// </summary>
	/// <returns>Original type: ImWchar16</returns>
	public ushort InputQueueSurrogate;

	/// <summary>
	/// Queue of _characters_ input (obtained by platform backend). Fill using AddInputCharacter() helper.
	/// </summary>
	public ImVector_ImWchar InputQueueCharacters;

}
/// <summary>
/// <para>Shared state of InputText(), passed as an argument to your callback when a ImGuiInputTextFlags_Callback* flag is used.</para>
/// <para>The callback function should return 0 by default.</para>
/// <para>Callbacks (follow a flag name and see comments in ImGuiInputTextFlags_ declarations for more details)</para>
/// <para>- ImGuiInputTextFlags_CallbackEdit:        Callback on buffer edit (note that InputText() already returns true on edit, the callback is useful mainly to manipulate the underlying buffer while focus is active)</para>
/// <para>- ImGuiInputTextFlags_CallbackAlways:      Callback on each iteration</para>
/// <para>- ImGuiInputTextFlags_CallbackCompletion:  Callback on pressing TAB</para>
/// <para>- ImGuiInputTextFlags_CallbackHistory:     Callback on pressing Up/Down arrows</para>
/// <para>- ImGuiInputTextFlags_CallbackCharFilter:  Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.</para>
/// <para>- ImGuiInputTextFlags_CallbackResize:      Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow.</para>
/// </summary>
public struct ImGuiInputTextCallbackData
{
	/// <summary>
	/// Parent UI context
	/// </summary>
	public unsafe ImGuiContext* Ctx;

	/// <summary>
	/// One ImGuiInputTextFlags_Callback*    // Read-only
	/// </summary>
	public ImGuiInputTextFlags EventFlag;

	/// <summary>
	/// What user passed to InputText()      // Read-only
	/// </summary>
	public ImGuiInputTextFlags Flags;

	/// <summary>
	/// What user passed to InputText()      // Read-only
	/// </summary>
	public unsafe void* UserData;

	/// <summary>
	/// <para>Arguments for the different callback events</para>
	/// <para>- To modify the text buffer in a callback, prefer using the InsertChars() / DeleteChars() function. InsertChars() will take care of calling the resize callback if necessary.</para>
	/// <para>- If you know your edits are not going to resize the underlying buffer allocation, you may modify the contents of 'Buf[]' directly. You need to update 'BufTextLen' accordingly (0 &lt;= BufTextLen &lt; BufSize) and set 'BufDirty'' to true so InputText can update its internal state.</para>
	/// </summary>
	/// <para/><summary>
	/// Character input                      // Read-write   // [CharFilter] Replace character with another one, or set to zero to drop. return 1 is equivalent to setting EventChar=0;
	/// </summary>
	/// <returns>Original type: ImWchar</returns>
	public ushort EventChar;

	/// <summary>
	/// Key pressed (Up/Down/TAB)            // Read-only    // [Completion,History]
	/// </summary>
	public ImGuiKey EventKey;

	/// <summary>
	/// Text buffer                          // Read-write   // [Resize] Can replace pointer / [Completion,History,Always] Only write to pointed data, don't replace the actual pointer!
	/// </summary>
	public unsafe byte* Buf;

	/// <summary>
	/// Text length (in bytes)               // Read-write   // [Resize,Completion,History,Always] Exclude zero-terminator storage. In C land: == strlen(some_text), in C++ land: string.length()
	/// </summary>
	public int BufTextLen;

	/// <summary>
	/// Buffer size (in bytes) = capacity+1  // Read-only    // [Resize,Completion,History,Always] Include zero-terminator storage. In C land == ARRAYSIZE(my_char_array), in C++ land: string.capacity()+1
	/// </summary>
	public int BufSize;

	/// <summary>
	/// Set if you modify Buf/BufTextLen!    // Write        // [Completion,History,Always]
	/// </summary>
	public bool BufDirty;

	/// <summary>
	///                                      // Read-write   // [Completion,History,Always]
	/// </summary>
	public int CursorPos;

	/// <summary>
	///                                      // Read-write   // [Completion,History,Always] == to SelectionEnd when no selection)
	/// </summary>
	public int SelectionStart;

	/// <summary>
	///                                      // Read-write   // [Completion,History,Always]
	/// </summary>
	public int SelectionEnd;

}
/// <summary>
/// <para>Resizing callback data to apply custom constraint. As enabled by SetNextWindowSizeConstraints(). Callback is called during the next Begin().</para>
/// <para>NB: For basic min/max size constraint on each axis you don't need to use the callback! The SetNextWindowSizeConstraints() parameters are enough.</para>
/// </summary>
public struct ImGuiSizeCallbackData
{
	/// <summary>
	/// Read-only.   What user passed to SetNextWindowSizeConstraints(). Generally store an integer or float in here (need reinterpret_cast&lt;&gt;).
	/// </summary>
	public unsafe void* UserData;

	/// <summary>
	/// Read-only.   Window position, for reference.
	/// </summary>
	public ImVec2 Pos;

	/// <summary>
	/// Read-only.   Current window size.
	/// </summary>
	public ImVec2 CurrentSize;

	/// <summary>
	/// Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.
	/// </summary>
	public ImVec2 DesiredSize;

}
/// <summary>
/// <para>Data payload for Drag and Drop operations: AcceptDragDropPayload(), GetDragDropPayload()</para>
/// </summary>
public struct ImGuiPayload
{
	/// <summary>
	/// <para>Members</para>
	/// </summary>
	/// <para/><summary>
	/// Data (copied and owned by dear imgui)
	/// </summary>
	public unsafe void* Data;

	/// <summary>
	/// Data size
	/// </summary>
	public int DataSize;

	/// <summary>
	/// <para>[Internal]</para>
	/// </summary>
	/// <para/><summary>
	/// Source item id
	/// </summary>
	/// <returns>Original type: ImGuiID</returns>
	public uint SourceId;

	/// <summary>
	/// Source parent id (if available)
	/// </summary>
	/// <returns>Original type: ImGuiID</returns>
	public uint SourceParentId;

	/// <summary>
	/// Data timestamp
	/// </summary>
	public int DataFrameCount;

	/// <summary>
	/// Data type tag (short user-supplied string, 32 characters max)
	/// </summary>
	public unsafe fixed byte DataType[(int)(32+1)];

	/// <summary>
	/// Set when AcceptDragDropPayload() was called and mouse has been hovering the target item (nb: handle overlapping drag targets)
	/// </summary>
	public bool Preview;

	/// <summary>
	/// Set when AcceptDragDropPayload() was called and mouse button is released over the target item.
	/// </summary>
	public bool Delivery;

}
/// <summary>
/// <para>[Internal]</para>
/// </summary>
public struct ImGuiTextFilter_ImGuiTextRange
{
	public unsafe byte* b;

	public unsafe byte* e;

}
/// <summary>
/// <para>Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"</para>
/// </summary>
public struct ImGuiTextFilter
{
	public unsafe fixed byte InputBuf[256];

	public ImVector_ImGuiTextFilter_ImGuiTextRange Filters;

	public int CountGrep;

}
/// <summary>
/// <para>Helper: Growable text buffer for logging/accumulating text</para>
/// <para>(this could be called 'ImGuiTextBuilder' / 'ImGuiStringBuilder')</para>
/// </summary>
public struct ImGuiTextBuffer
{
	public ImVector_char Buf;

}
/// <summary>
/// <para>[Internal]</para>
/// </summary>
public struct ImGuiStorage_ImGuiStoragePair
{
	/// <returns>Original type: ImGuiID</returns>
	public uint key;

	public __anonymous_type0 __anonymous_type0;

}
public struct __anonymous_type0
{
	public int val_i;

	public float val_f;

	public unsafe void* val_p;

}
/// <summary>
/// <para>Helper: Key-&gt;Value storage</para>
/// <para>Typically you don't have to worry about this since a storage is held within each Window.</para>
/// <para>We use it to e.g. store collapse state for a tree (Int 0/1)</para>
/// <para>This is optimized for efficient lookup (dichotomy into a contiguous buffer) and rare insertion (typically tied to user interactions aka max once a frame)</para>
/// <para>You can use it as custom user storage for temporary values. Declare your own storage if, for example:</para>
/// <para>- You want to manipulate the open/close state of a particular sub-tree in your interface (tree node uses Int 0/1 to store their state).</para>
/// <para>- You want to store custom debug data easily without adding or editing structures in your code (probably not efficient, but convenient)</para>
/// <para>Types are NOT stored, so it is up to you to make sure your Key don't collide with different types.</para>
/// </summary>
public struct ImGuiStorage
{
	public ImVector_ImGuiStorage_ImGuiStoragePair Data;

}
/// <summary>
/// <para>Helper: Manually clip large list of items.</para>
/// <para>If you have lots evenly spaced items and you have random access to the list, you can perform coarse</para>
/// <para>clipping based on visibility to only submit items that are in view.</para>
/// <para>The clipper calculates the range of visible items and advance the cursor to compensate for the non-visible items we have skipped.</para>
/// <para>(Dear ImGui already clip items based on their bounds but: it needs to first layout the item to do so, and generally</para>
/// <para> fetching/submitting your own data incurs additional cost. Coarse clipping using ImGuiListClipper allows you to easily</para>
/// <para> scale using lists with tens of thousands of items without a problem)</para>
/// <para>Usage:</para>
/// <para>  ImGuiListClipper clipper;</para>
/// <para>  clipper.Begin(1000);         // We have 1000 elements, evenly spaced.</para>
/// <para>  while (clipper.Step())</para>
/// <para>      for (int i = clipper.DisplayStart; i &lt; clipper.DisplayEnd; i++)</para>
/// <para>          ImGui::Text("line number %d", i);</para>
/// <para>Generally what happens is:</para>
/// <para>- Clipper lets you process the first element (DisplayStart = 0, DisplayEnd = 1) regardless of it being visible or not.</para>
/// <para>- User code submit that one element.</para>
/// <para>- Clipper can measure the height of the first element</para>
/// <para>- Clipper calculate the actual range of elements to display based on the current clipping rectangle, position the cursor before the first visible element.</para>
/// <para>- User code submit visible elements.</para>
/// <para>- The clipper also handles various subtleties related to keyboard/gamepad navigation, wrapping etc.</para>
/// </summary>
public struct ImGuiListClipper
{
	/// <summary>
	/// Parent UI context
	/// </summary>
	public unsafe ImGuiContext* Ctx;

	/// <summary>
	/// First item to display, updated by each call to Step()
	/// </summary>
	public int DisplayStart;

	/// <summary>
	/// End of items to display (exclusive)
	/// </summary>
	public int DisplayEnd;

	/// <summary>
	/// [Internal] Number of items
	/// </summary>
	public int ItemsCount;

	/// <summary>
	/// [Internal] Height of item after a first step and item submission can calculate it
	/// </summary>
	public float ItemsHeight;

	/// <summary>
	/// [Internal] Cursor position at the time of Begin() or after table frozen rows are all processed
	/// </summary>
	public float StartPosY;

	/// <summary>
	/// [Internal] Internal data
	/// </summary>
	public unsafe void* TempData;

}
/// <summary>
/// <para>Helper: ImColor() implicitly converts colors to either ImU32 (packed 4x1 byte) or ImVec4 (4x1 float)</para>
/// <para>Prefer using IM_COL32() macros if you want a guaranteed compile-time ImU32 for usage with ImDrawList API.</para>
/// <para>**Avoid storing ImColor! Store either u32 of ImVec4. This is not a full-featured color class. MAY OBSOLETE.</para>
/// <para>**None of the ImGui API are using ImColor directly but you can use it as a convenience to pass colors in either ImU32 or ImVec4 formats. Explicitly cast to ImU32 or ImVec4 if needed.</para>
/// </summary>
public struct ImColor
{
	public ImVec4 Value;

}
/// <summary>
/// <para>Typically, 1 command = 1 GPU draw call (unless command is a callback)</para>
/// <para>- VtxOffset: When 'io.BackendFlags &amp; ImGuiBackendFlags_RendererHasVtxOffset' is enabled,</para>
/// <para>  this fields allow us to render meshes larger than 64K vertices while keeping 16-bit indices.</para>
/// <para>  Backends made for &lt;1.71. will typically ignore the VtxOffset fields.</para>
/// <para>- The ClipRect/TextureId/VtxOffset fields must be contiguous as we memcmp() them together (this is asserted for).</para>
/// </summary>
public struct ImDrawCmd
{
	/// <summary>
	/// 4*4  // Clipping rectangle (x1, y1, x2, y2). Subtract ImDrawData-&gt;DisplayPos to get clipping rectangle in "viewport" coordinates
	/// </summary>
	public ImVec4 ClipRect;

	/// <summary>
	/// 4-8  // User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.
	/// </summary>
	/// <returns>Original type: ImTextureID</returns>
	public unsafe void* TextureId;

	/// <summary>
	/// 4    // Start offset in vertex buffer. ImGuiBackendFlags_RendererHasVtxOffset: always 0, otherwise may be &gt;0 to support meshes larger than 64K vertices with 16-bit indices.
	/// </summary>
	public uint VtxOffset;

	/// <summary>
	/// 4    // Start offset in index buffer.
	/// </summary>
	public uint IdxOffset;

	/// <summary>
	/// 4    // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].
	/// </summary>
	public uint ElemCount;

	/// <summary>
	/// 4-8  // If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.
	/// </summary>
	public ImDrawCallback UserCallback;

	/// <summary>
	/// 4-8  // The draw callback code can access this.
	/// </summary>
	public unsafe void* UserCallbackData;

}
public struct ImDrawVert
{
	public ImVec2 pos;

	public ImVec2 uv;

	/// <returns>Original type: ImU32</returns>
	public uint col;

}
/// <summary>
/// <para>[Internal] For use by ImDrawList</para>
/// </summary>
public struct ImDrawCmdHeader
{
	public ImVec4 ClipRect;

	/// <returns>Original type: ImTextureID</returns>
	public unsafe void* TextureId;

	public uint VtxOffset;

}
/// <summary>
/// <para>[Internal] For use by ImDrawListSplitter</para>
/// </summary>
public struct ImDrawChannel
{
	public ImVector_ImDrawCmd _CmdBuffer;

	public ImVector_ImDrawIdx _IdxBuffer;

}
/// <summary>
/// <para>Split/Merge functions are used to split the draw list into different layers which can be drawn into out of order.</para>
/// <para>This is used by the Columns/Tables API, so items of each column can be batched together in a same draw call.</para>
/// </summary>
public struct ImDrawListSplitter
{
	/// <summary>
	/// Current channel number (0)
	/// </summary>
	public int _Current;

	/// <summary>
	/// Number of active channels (1+)
	/// </summary>
	public int _Count;

	/// <summary>
	/// Draw channels (not resized down so _Count might be &lt; Channels.Size)
	/// </summary>
	public ImVector_ImDrawChannel _Channels;

}
/// <summary>
/// <para>Draw command list</para>
/// <para>This is the low-level list of polygons that ImGui:: functions are filling. At the end of the frame,</para>
/// <para>all command lists are passed to your ImGuiIO::RenderDrawListFn function for rendering.</para>
/// <para>Each dear imgui window contains its own ImDrawList. You can use ImGui::GetWindowDrawList() to</para>
/// <para>access the current window draw list and draw custom primitives.</para>
/// <para>You can interleave normal ImGui:: calls and adding primitives to the current draw list.</para>
/// <para>In single viewport mode, top-left is == GetMainViewport()-&gt;Pos (generally 0,0), bottom-right is == GetMainViewport()-&gt;Pos+Size (generally io.DisplaySize).</para>
/// <para>You are totally free to apply whatever transformation matrix to want to the data (depending on the use of the transformation you may want to apply it to ClipRect as well!)</para>
/// <para>Important: Primitives are always added to the list and not culled (culling is done at higher-level by ImGui:: functions), if you use this API a lot consider coarse culling your drawn objects.</para>
/// </summary>
public struct ImDrawList
{
	/// <summary>
	/// <para>This is what you have to render</para>
	/// </summary>
	/// <para/><summary>
	/// Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.
	/// </summary>
	public ImVector_ImDrawCmd CmdBuffer;

	/// <summary>
	/// Index buffer. Each command consume ImDrawCmd::ElemCount of those
	/// </summary>
	public ImVector_ImDrawIdx IdxBuffer;

	/// <summary>
	/// Vertex buffer.
	/// </summary>
	public ImVector_ImDrawVert VtxBuffer;

	/// <summary>
	/// Flags, you may poke into these to adjust anti-aliasing settings per-primitive.
	/// </summary>
	public ImDrawListFlags Flags;

	/// <summary>
	/// <para>[Internal, used while building lists]</para>
	/// </summary>
	/// <para/><summary>
	/// [Internal] generally == VtxBuffer.Size unless we are past 64K vertices, in which case this gets reset to 0.
	/// </summary>
	public uint _VtxCurrentIdx;

	/// <summary>
	/// Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)
	/// </summary>
	public unsafe ImDrawListSharedData* _Data;

	/// <summary>
	/// Pointer to owner window's name for debugging
	/// </summary>
	public unsafe byte* _OwnerName;

	/// <summary>
	/// [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector&lt;&gt; operators too much)
	/// </summary>
	public unsafe ImDrawVert* _VtxWritePtr;

	/// <summary>
	/// [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector&lt;&gt; operators too much)
	/// </summary>
	/// <returns>Original type: ImDrawIdx*</returns>
	public unsafe ushort* _IdxWritePtr;

	/// <summary>
	/// [Internal]
	/// </summary>
	public ImVector_ImVec4 _ClipRectStack;

	/// <summary>
	/// [Internal]
	/// </summary>
	public ImVector_ImTextureID _TextureIdStack;

	/// <summary>
	/// [Internal] current path building
	/// </summary>
	public ImVector_ImVec2 _Path;

	/// <summary>
	/// [Internal] template of active commands. Fields should match those of CmdBuffer.back().
	/// </summary>
	public ImDrawCmdHeader _CmdHeader;

	/// <summary>
	/// [Internal] for channels api (note: prefer using your own persistent instance of ImDrawListSplitter!)
	/// </summary>
	public ImDrawListSplitter _Splitter;

	/// <summary>
	/// [Internal] anti-alias fringe is scaled by this value, this helps to keep things sharp while zooming at vertex buffer content
	/// </summary>
	public float _FringeScale;

}
/// <summary>
/// <para>All draw data to render a Dear ImGui frame</para>
/// <para>(NB: the style and the naming convention here is a little inconsistent, we currently preserve them for backward compatibility purpose,</para>
/// <para>as this is one of the oldest structure exposed by the library! Basically, ImDrawList == CmdList)</para>
/// </summary>
public struct ImDrawData
{
	/// <summary>
	/// Only valid after Render() is called and before the next NewFrame() is called.
	/// </summary>
	public bool Valid;

	/// <summary>
	/// Number of ImDrawList* to render (should always be == CmdLists.size)
	/// </summary>
	public int CmdListsCount;

	/// <summary>
	/// For convenience, sum of all ImDrawList's IdxBuffer.Size
	/// </summary>
	public int TotalIdxCount;

	/// <summary>
	/// For convenience, sum of all ImDrawList's VtxBuffer.Size
	/// </summary>
	public int TotalVtxCount;

	/// <summary>
	/// Array of ImDrawList* to render. The ImDrawLists are owned by ImGuiContext and only pointed to from here.
	/// </summary>
	public ImVector_ImDrawListPtr CmdLists;

	/// <summary>
	/// Top-left position of the viewport to render (== top-left of the orthogonal projection matrix to use) (== GetMainViewport()-&gt;Pos for the main viewport, == (0.0) in most single-viewport applications)
	/// </summary>
	public ImVec2 DisplayPos;

	/// <summary>
	/// Size of the viewport to render (== GetMainViewport()-&gt;Size for the main viewport, == io.DisplaySize in most single-viewport applications)
	/// </summary>
	public ImVec2 DisplaySize;

	/// <summary>
	/// Amount of pixels for each unit of DisplaySize. Based on io.DisplayFramebufferScale. Generally (1,1) on normal display, (2,2) on OSX with Retina display.
	/// </summary>
	public ImVec2 FramebufferScale;

	/// <summary>
	/// Viewport carrying the ImDrawData instance, might be of use to the renderer (generally not).
	/// </summary>
	public unsafe ImGuiViewport* OwnerViewport;

}
public struct ImFontConfig
{
	/// <summary>
	///          // TTF/OTF data
	/// </summary>
	public unsafe void* FontData;

	/// <summary>
	///          // TTF/OTF data size
	/// </summary>
	public int FontDataSize;

	/// <summary>
	/// true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).
	/// </summary>
	public bool FontDataOwnedByAtlas;

	/// <summary>
	/// 0        // Index of font within TTF/OTF file
	/// </summary>
	public int FontNo;

	/// <summary>
	///          // Size in pixels for rasterizer (more or less maps to the resulting font height).
	/// </summary>
	public float SizePixels;

	/// <summary>
	/// 2        // Rasterize at higher quality for sub-pixel positioning. Note the difference between 2 and 3 is minimal. You can reduce this to 1 for large glyphs save memory. Read https://github.com/nothings/stb/blob/master/tests/oversample/README.md for details.
	/// </summary>
	public int OversampleH;

	/// <summary>
	/// 1        // Rasterize at higher quality for sub-pixel positioning. This is not really useful as we don't use sub-pixel positions on the Y axis.
	/// </summary>
	public int OversampleV;

	/// <summary>
	/// false    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.
	/// </summary>
	public bool PixelSnapH;

	/// <summary>
	/// 0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.
	/// </summary>
	public ImVec2 GlyphExtraSpacing;

	/// <summary>
	/// 0, 0     // Offset all glyphs from this font input.
	/// </summary>
	public ImVec2 GlyphOffset;

	/// <summary>
	/// NULL     // THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE. Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list).
	/// </summary>
	/// <returns>Original type: ImWchar*</returns>
	public unsafe ushort* GlyphRanges;

	/// <summary>
	/// 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font
	/// </summary>
	public float GlyphMinAdvanceX;

	/// <summary>
	/// FLT_MAX  // Maximum AdvanceX for glyphs
	/// </summary>
	public float GlyphMaxAdvanceX;

	/// <summary>
	/// false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.
	/// </summary>
	public bool MergeMode;

	/// <summary>
	/// 0        // Settings for custom font builder. THIS IS BUILDER IMPLEMENTATION DEPENDENT. Leave as zero if unsure.
	/// </summary>
	public uint FontBuilderFlags;

	/// <summary>
	/// 1.0f     // Linearly brighten (&gt;1.0f) or darken (&lt;1.0f) font output. Brightening small fonts may be a good workaround to make them more readable. This is a silly thing we may remove in the future.
	/// </summary>
	public float RasterizerMultiply;

	/// <summary>
	/// 1.0f     // DPI scale for rasterization, not altering other font metrics: make it easy to swap between e.g. a 100% and a 400% fonts for a zooming display. IMPORTANT: If you increase this it is expected that you increase font scale accordingly, otherwise quality may look lowered.
	/// </summary>
	public float RasterizerDensity;

	/// <summary>
	/// -1       // Explicitly specify unicode codepoint of ellipsis character. When fonts are being merged first specified ellipsis will be used.
	/// </summary>
	/// <returns>Original type: ImWchar</returns>
	public ushort EllipsisChar;

	/// <summary>
	/// <para>[Internal]</para>
	/// </summary>
	/// <para/><summary>
	/// Name (strictly to ease debugging)
	/// </summary>
	public unsafe fixed byte Name[40];

	public unsafe ImFont* DstFont;

}
/// <summary>
/// <para>Hold rendering data for one glyph.</para>
/// <para>(Note: some language parsers may fail to convert the 31+1 bitfield members, in this case maybe drop store a single u32 or we can rework this)</para>
/// </summary>
public struct ImFontGlyph
{
	/// <summary>
	/// Flag to indicate glyph is colored and should generally ignore tinting (make it usable with no shift on little-endian as this is used in loops)
	/// </summary>
	public uint Colored;

	/// <summary>
	/// Flag to indicate glyph has no visible pixels (e.g. space). Allow early out when rendering.
	/// </summary>
	public uint Visible;

	/// <summary>
	/// 0x0000..0x10FFFF
	/// </summary>
	public uint Codepoint;

	/// <summary>
	/// Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)
	/// </summary>
	public float AdvanceX;

	/// <summary>
	/// Glyph corners
	/// </summary>
	public float X0;

	/// <summary>
	/// Glyph corners
	/// </summary>
	public float Y0;

	/// <summary>
	/// Glyph corners
	/// </summary>
	public float X1;

	/// <summary>
	/// Glyph corners
	/// </summary>
	public float Y1;

	/// <summary>
	/// Texture coordinates
	/// </summary>
	public float U0;

	/// <summary>
	/// Texture coordinates
	/// </summary>
	public float V0;

	/// <summary>
	/// Texture coordinates
	/// </summary>
	public float U1;

	/// <summary>
	/// Texture coordinates
	/// </summary>
	public float V1;

}
/// <summary>
/// <para>Helper to build glyph ranges from text/string data. Feed your application strings/characters to it then call BuildRanges().</para>
/// <para>This is essentially a tightly packed of vector of 64k booleans = 8KB storage.</para>
/// </summary>
public struct ImFontGlyphRangesBuilder
{
	/// <summary>
	/// Store 1-bit per Unicode code point (0=unused, 1=used)
	/// </summary>
	public ImVector_ImU32 UsedChars;

}
/// <summary>
/// <para>See ImFontAtlas::AddCustomRectXXX functions.</para>
/// </summary>
public struct ImFontAtlasCustomRect
{
	/// <summary>
	/// Input    // Desired rectangle dimension
	/// </summary>
	public ushort Width;

	/// <summary>
	/// Input    // Desired rectangle dimension
	/// </summary>
	public ushort Height;

	/// <summary>
	/// Output   // Packed position in Atlas
	/// </summary>
	public ushort X;

	/// <summary>
	/// Output   // Packed position in Atlas
	/// </summary>
	public ushort Y;

	/// <summary>
	/// Input    // For custom font glyphs only (ID &lt; 0x110000)
	/// </summary>
	public uint GlyphID;

	/// <summary>
	/// Input    // For custom font glyphs only: glyph xadvance
	/// </summary>
	public float GlyphAdvanceX;

	/// <summary>
	/// Input    // For custom font glyphs only: glyph display offset
	/// </summary>
	public ImVec2 GlyphOffset;

	/// <summary>
	/// Input    // For custom font glyphs only: target font
	/// </summary>
	public unsafe ImFont* Font;

}
/// <summary>
/// <para>Load and rasterize multiple TTF/OTF fonts into a same texture. The font atlas will build a single texture holding:</para>
/// <para> - One or more fonts.</para>
/// <para> - Custom graphics data needed to render the shapes needed by Dear ImGui.</para>
/// <para> - Mouse cursor shapes for software cursor rendering (unless setting 'Flags |= ImFontAtlasFlags_NoMouseCursors' in the font atlas).</para>
/// <para>It is the user-code responsibility to setup/build the atlas, then upload the pixel data into a texture accessible by your graphics api.</para>
/// <para> - Optionally, call any of the AddFont*** functions. If you don't call any, the default font embedded in the code will be loaded for you.</para>
/// <para> - Call GetTexDataAsAlpha8() or GetTexDataAsRGBA32() to build and retrieve pixels data.</para>
/// <para> - Upload the pixels data into a texture within your graphics system (see imgui_impl_xxxx.cpp examples)</para>
/// <para> - Call SetTexID(my_tex_id); and pass the pointer/identifier to your texture in a format natural to your graphics API.</para>
/// <para>   This value will be passed back to you during rendering to identify the texture. Read FAQ entry about ImTextureID for more details.</para>
/// <para>Common pitfalls:</para>
/// <para>- If you pass a 'glyph_ranges' array to AddFont*** functions, you need to make sure that your array persist up until the</para>
/// <para>  atlas is build (when calling GetTexData*** or Build()). We only copy the pointer, not the data.</para>
/// <para>- Important: By default, AddFontFromMemoryTTF() takes ownership of the data. Even though we are not writing to it, we will free the pointer on destruction.</para>
/// <para>  You can set font_cfg-&gt;FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed,</para>
/// <para>- Even though many functions are suffixed with "TTF", OTF data is supported just as well.</para>
/// <para>- This is an old API and it is currently awkward for those and various other reasons! We will address them in the future!</para>
/// </summary>
public struct ImFontAtlas
{
	/// <summary>
	/// Build flags (see ImFontAtlasFlags_)
	/// </summary>
	public ImFontAtlasFlags Flags;

	/// <summary>
	/// User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.
	/// </summary>
	/// <returns>Original type: ImTextureID</returns>
	public unsafe void* TexID;

	/// <summary>
	/// Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.
	/// </summary>
	public int TexDesiredWidth;

	/// <summary>
	/// Padding between glyphs within texture in pixels. Defaults to 1. If your rendering method doesn't rely on bilinear filtering you may set this to 0 (will also need to set AntiAliasedLinesUseTex = false).
	/// </summary>
	public int TexGlyphPadding;

	/// <summary>
	/// Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.
	/// </summary>
	public bool Locked;

	/// <summary>
	/// Store your own atlas related user-data (if e.g. you have multiple font atlas).
	/// </summary>
	public unsafe void* UserData;

	/// <summary>
	/// <para>[Internal]</para>
	/// <para>NB: Access texture data via GetTexData*() calls! Which will setup a default font for you.</para>
	/// </summary>
	/// <para/><summary>
	/// Set when texture was built matching current font input
	/// </summary>
	public bool TexReady;

	/// <summary>
	/// Tell whether our texture data is known to use colors (rather than just alpha channel), in order to help backend select a format.
	/// </summary>
	public bool TexPixelsUseColors;

	/// <summary>
	/// 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight
	/// </summary>
	public unsafe byte* TexPixelsAlpha8;

	/// <summary>
	/// 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4
	/// </summary>
	public unsafe uint* TexPixelsRGBA32;

	/// <summary>
	/// Texture width calculated during Build().
	/// </summary>
	public int TexWidth;

	/// <summary>
	/// Texture height calculated during Build().
	/// </summary>
	public int TexHeight;

	/// <summary>
	/// = (1.0f/TexWidth, 1.0f/TexHeight)
	/// </summary>
	public ImVec2 TexUvScale;

	/// <summary>
	/// Texture coordinates to a white pixel
	/// </summary>
	public ImVec2 TexUvWhitePixel;

	/// <summary>
	/// Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()/PopFont() to change the current font.
	/// </summary>
	public ImVector_ImFontPtr Fonts;

	/// <summary>
	/// Rectangles for packing custom texture data into the atlas.
	/// </summary>
	public ImVector_ImFontAtlasCustomRect CustomRects;

	/// <summary>
	/// Configuration data
	/// </summary>
	public ImVector_ImFontConfig ConfigData;

	/// <summary>
	/// UVs for baked anti-aliased lines
	/// </summary>
	public ImFontAtlas_TexUvLinesInlineArray TexUvLines;

	/// <summary>
	/// <para>[Internal] Font builder</para>
	/// </summary>
	/// <para/><summary>
	/// Opaque interface to a font builder (default to stb_truetype, can be changed to use FreeType by defining IMGUI_ENABLE_FREETYPE).
	/// </summary>
	public unsafe ImFontBuilderIO* FontBuilderIO;

	/// <summary>
	/// Shared flags (for all fonts) for custom font builder. THIS IS BUILD IMPLEMENTATION DEPENDENT. Per-font override is also available in ImFontConfig.
	/// </summary>
	public uint FontBuilderFlags;

	/// <summary>
	/// <para>[Internal] Packing data</para>
	/// </summary>
	/// <para/><summary>
	/// Custom texture rectangle ID for white pixel and mouse cursors
	/// </summary>
	public int PackIdMouseCursors;

	/// <summary>
	/// Custom texture rectangle ID for baked anti-aliased lines
	/// </summary>
	public int PackIdLines;

}
/// <summary>
/// <para>Font runtime data and rendering</para>
/// <para>ImFontAtlas automatically loads a default embedded font for you when you call GetTexDataAsAlpha8() or GetTexDataAsRGBA32().</para>
/// </summary>
public struct ImFont
{
	/// <summary>
	/// <para>Members: Hot ~20/24 bytes (for CalcTextSize)</para>
	/// </summary>
	/// <para/><summary>
	/// 12-16 // out //            // Sparse. Glyphs-&gt;AdvanceX in a directly indexable way (cache-friendly for CalcTextSize functions which only this this info, and are often bottleneck in large UI).
	/// </summary>
	public ImVector_float IndexAdvanceX;

	/// <summary>
	/// 4     // out // = FallbackGlyph-&gt;AdvanceX
	/// </summary>
	public float FallbackAdvanceX;

	/// <summary>
	/// 4     // in  //            // Height of characters/line, set during loading (don't change after loading)
	/// </summary>
	public float FontSize;

	/// <summary>
	/// <para>Members: Hot ~28/40 bytes (for CalcTextSize + render loop)</para>
	/// </summary>
	/// <para/><summary>
	/// 12-16 // out //            // Sparse. Index glyphs by Unicode code-point.
	/// </summary>
	public ImVector_ImWchar IndexLookup;

	/// <summary>
	/// 12-16 // out //            // All glyphs.
	/// </summary>
	public ImVector_ImFontGlyph Glyphs;

	/// <summary>
	/// 4-8   // out // = FindGlyph(FontFallbackChar)
	/// </summary>
	public unsafe ImFontGlyph* FallbackGlyph;

	/// <summary>
	/// <para>Members: Cold ~32/40 bytes</para>
	/// </summary>
	/// <para/><summary>
	/// 4-8   // out //            // What we has been loaded into
	/// </summary>
	public unsafe ImFontAtlas* ContainerAtlas;

	/// <summary>
	/// 4-8   // in  //            // Pointer within ContainerAtlas-&gt;ConfigData
	/// </summary>
	public unsafe ImFontConfig* ConfigData;

	/// <summary>
	/// 2     // in  // ~ 1        // Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.
	/// </summary>
	public short ConfigDataCount;

	/// <summary>
	/// 2     // out // = FFFD/'?' // Character used if a glyph isn't found.
	/// </summary>
	/// <returns>Original type: ImWchar</returns>
	public ushort FallbackChar;

	/// <summary>
	/// 2     // out // = '...'/'.'// Character used for ellipsis rendering.
	/// </summary>
	/// <returns>Original type: ImWchar</returns>
	public ushort EllipsisChar;

	/// <summary>
	/// 1     // out // 1 or 3
	/// </summary>
	public short EllipsisCharCount;

	/// <summary>
	/// 4     // out               // Width
	/// </summary>
	public float EllipsisWidth;

	/// <summary>
	/// 4     // out               // Step between characters when EllipsisCount &gt; 0
	/// </summary>
	public float EllipsisCharStep;

	/// <summary>
	/// 1     // out //
	/// </summary>
	public bool DirtyLookupTables;

	/// <summary>
	/// 4     // in  // = 1.f      // Base font scale, multiplied by the per-window font scale which you can adjust with SetWindowFontScale()
	/// </summary>
	public float Scale;

	/// <summary>
	/// 4+4   // out //            // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]
	/// </summary>
	public float Ascent;

	/// <summary>
	/// 4+4   // out //            // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]
	/// </summary>
	public float Descent;

	/// <summary>
	/// 4     // out //            // Total surface in pixels to get an idea of the font rasterization/texture cost (not exact, we approximate the cost of padding between glyphs)
	/// </summary>
	public int MetricsTotalSurface;

	/// <summary>
	/// 2 bytes if ImWchar=ImWchar16, 34 bytes if ImWchar==ImWchar32. Store 1-bit for each block of 4K codepoints that has one active glyph. This is mainly used to facilitate iterations across all used codepoints.
	/// </summary>
	/// <returns>Original type: ImU8</returns>
	public unsafe fixed byte Used4kPagesMap[(int)((IM_UNICODE_CODEPOINT_MAX +1)/4096/8)];

}
/// <summary>
/// <para>- Currently represents the Platform Window created by the application which is hosting our Dear ImGui windows.</para>
/// <para>- In 'docking' branch with multi-viewport enabled, we extend this concept to have multiple active viewports.</para>
/// <para>- In the future we will extend this concept further to also represent Platform Monitor and support a "no main platform window" operation mode.</para>
/// <para>- About Main Area vs Work Area:</para>
/// <para>  - Main Area = entire viewport.</para>
/// <para>  - Work Area = entire viewport minus sections used by main menu bars (for platform windows), or by task bar (for platform monitor).</para>
/// <para>  - Windows are generally trying to stay within the Work Area of their host viewport.</para>
/// </summary>
public struct ImGuiViewport
{
	/// <summary>
	/// Unique identifier for the viewport
	/// </summary>
	/// <returns>Original type: ImGuiID</returns>
	public uint ID;

	/// <summary>
	/// See ImGuiViewportFlags_
	/// </summary>
	public ImGuiViewportFlags Flags;

	/// <summary>
	/// Main Area: Position of the viewport (Dear ImGui coordinates are the same as OS desktop/native coordinates)
	/// </summary>
	public ImVec2 Pos;

	/// <summary>
	/// Main Area: Size of the viewport.
	/// </summary>
	public ImVec2 Size;

	/// <summary>
	/// Work Area: Position of the viewport minus task bars, menus bars, status bars (&gt;= Pos)
	/// </summary>
	public ImVec2 WorkPos;

	/// <summary>
	/// Work Area: Size of the viewport minus task bars, menu bars, status bars (&lt;= Size)
	/// </summary>
	public ImVec2 WorkSize;

	/// <summary>
	/// <para>Platform/Backend Dependent Data</para>
	/// </summary>
	/// <para/><summary>
	/// void* to hold lower-level, platform-native window handle (under Win32 this is expected to be a HWND, unused for other platforms)
	/// </summary>
	public unsafe void* PlatformHandleRaw;

}
/// <summary>
/// <para>(Optional) Support for IME (Input Method Editor) via the io.SetPlatformImeDataFn() function.</para>
/// </summary>
public struct ImGuiPlatformImeData
{
	/// <summary>
	/// A widget wants the IME to be visible
	/// </summary>
	public bool WantVisible;

	/// <summary>
	/// Position of the input cursor
	/// </summary>
	public ImVec2 InputPos;

	/// <summary>
	/// Line height
	/// </summary>
	public float InputLineHeight;

}
